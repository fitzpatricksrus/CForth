#ifndef _warmStart_#define _warmStart_// RECORD DEFINITIONS#if __option( int_4)	enum { 		nameRec_size = 0,		nameRec_refCount = 4,		nameRec_nextRec = 8,		nameRec_unused1 = 12,		nameRec_flags = 16,		nameRec_nameRec = 20, 		nameRec_thread = 24, 		nameRec_nameStr = 28,		SZ_nameRec = 28		};	enum { 		wordRec_size = 0, 		wordRec_refCount = 4, 		wordRec_nextRec = 8, 		wordRec_unused1 = 12, 		wordRec_flags = 16, 		wordRec_nameRec = 20, 			wordRec_threads = 24,		SZ_wordRec = 24		 };	#define maxStrSize (64 - nameRec_nameStr)#else	enum { 		nameRec_size = 0,		nameRec_refCount = 2,		nameRec_nextRec = 4,		nameRec_unused1 = 6,		nameRec_flags = 8,		nameRec_nameRec = 10, 		nameRec_thread = 12, 		nameRec_nameStr = 14,		SZ_nameRec = 14		};	enum { 		wordRec_size = 0, 		wordRec_refCount = 2, 		wordRec_nextRec = 4, 		wordRec_unused1 = 6, 		wordRec_flags = 8, 		wordRec_nameRec = 10, 			wordRec_threads = 12,		SZ_wordRec = 12		 };	#define maxStrSize (64 - nameRec_nameStr)#endif// PRIMATIVE ROUTINES// pColdStartFailed (primative 1) is called when the definition for bootWordName//	can't be found after bootstrap code is all loaded.// pUndefinedWord (primative 2) is the code for a nameRec.  When a nameRec is //	executed (via pUndefinedWord), a special primative linker routine is called.//	The routine scans the current fContext for a definition for this word.  If it//	finds one, it replaces the reference to pUndefinedWord.  If it does not find//	a mathing definition, an error message of the following form is printed//	and execution is terminated.// pLiteral (primative 3) pushes the following thread on the user stack.// pExit is always the last thread in a word.	#define pCAt 			((token)-1)#define pAt 			((token)-2)#define pStore 			((token)-3)#define pCStore 		((token)-4)#define pCondBranch	 	((token)-5)#define pBitOr 			((token)-6)#define pBitAnd 		((token)-7)#define pBitNot 		((token)-8)#define pBitXor 		((token)-9)#define pPlus 			((token)-10)#define pMinus 			((token)-11)#define pDivide 		((token)-12)#define pMultiply 		((token)-13)#define pModulus 		((token)-14)#define pEqual 			((token)-15)#define pGreater 		((token)-16)#define pLess 			((token)-17)#define pExpect 		((token)-18)#define pEmit 			((token)-19)#define pUndefinedWord	((token)-20)#define pExitToShell		((token)-21)#define pLiteral		((token)-22)#define pExit			((token)-23)#define pToRS			((token)-24)#define pFromRS		((token)-25)#define pThreadSize		((token)-26)#define pfopen			((token)-27)#define pfclose			((token)-28)#define pfcreate		((token)-29)#define pfdelete		((token)-30)#define pfread			((token)-31)#define pfwrite			((token)-32)#define pfgetPos		((token)-33)#define pfsetPos		((token)-34)// PREDEFINED VARIABLES// fIP - the interpreter instruction pointer// fS0 - the base of the user stack// fSP - the top of the user stack (grows down)// fRSP - the interpreter return stack// fNameBase - the first item in the nameRec list	(changed during bootstrap)// fCurrent - the FORTH variable 'fCurrent' 		(changed during bootstrap)// fContext - the FORTH variable 'Context'// fState - reserved for future use// fBootStack - reserved for future use// fExitToShell - a thread containing the pExitToShell primative// fHere - the value returned by the FORTH word 'Here'enum { 	fIP = 		0x00, 		// instruction pointer	fMaxMem = 	0x04, 		// first byte beyond the end of memory	fRSP = 		0x08, 		// return stack pointer	fS0 = 		0x0C, 		// first byte beyond user stack	fSP = 		0x10, 		// user stack pointer	fNameBase = 	0x14, 		// token of first nameRec	fCurrent = 	0x18, 		// current compilation dictionary	fContext = 	0x1C, 		// current search dictionary	fError = 		0x20, 		// thread to error word	fExitToShell = 	0x24, 		// thread to exitToShell word	fState =		0x28,		// compiler state	fBootStack = 	0x2C,		// stack used at bootstrap time to allocate nameRec's	fTrace = 		0x30,		// trace interpreter run	fSpan = 		0x34,		// backwards stack used to allocate wordRecs	fList = 		0x38,		// backwards stack used to allocate wordRecs	fHere = 		0x3C };		// backwards stack used to allocate wordRecstypedef int token;#define tokenVal( x) (*((token*)(((Ptr)mem)+(x))))extern char *(primName[]);char *surroundingName( Ptr mem, token word);void WarmStart( Ptr mem);#endif