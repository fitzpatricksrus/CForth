{			}{ PRIMATIVES	}{			}: (EXIT) ;Primative 23: C@ ;Primative 1					{ addr -- c }	{ fetch the byte at addr }: @ ;Primative 2					{ addr -- w }	{ fetch the word at addr }: ! ;Primative 3						{ val addr -- }	{ store val at addr }: C! ;Primative 4					{ c addr -- }	{ store a byte at addr }: ?Branch	;Primative 5				{ conditional branch }: | ;Primative 6						{ a b -- a|b }	{ bitwise or }: & ;Primative 7					{ a b -- a&b }	{ bitwise and }: ^ ;Primative 8					{ a -- ^a }		{ bitwise not }: ;Primative  ;Primative 9			{ a b -- a~ b }	{ bitwise xor }: + ;Primative 10					{ a b -- a+b }: - ;Primative 11					{ a b -- a-b }: / ;Primative 12					{ a b -- a/b }: * ;Primative 13					{ a b -- a*b }: % ;Primative 14					{ a b -- a%b }	{ mod function }: = ;Primative 15					{ a b -- a=b }: > ;Primative 16					{ a b -- a>b }: < ;Primative 17					{ a b -- a<b }: Expect ;Primative 18				{ addr count -- }: Emit ;Primative 19					{ char -- }: pUndefinedWord ;Primative 20		{ }: pExitToShell ;Primative 21			{ }: (LITERAL) ;Primative 22				{ }{ : (EXIT) ;Primative 23 }				{ }: >R ;Primative 24					{ X -- }: R> ;Primative 25					{ -- X }: ThreadSize ;Primative 26			{ -- size }: fsOpen ;Primative 27				{ nameAddr -- ?refNum iErr }: fsClose ;Primative 28				{ refNum -- iErr }: fsCreate ;Primative 29				{ nameAddr -- iErr }: fsDelete ;Primative 30				{ nameAddr -- iErr }: fsRead ;Primative 31				{ count buf refNum -- iErr }: fsWrite ;Primative 32				{ count buf refNum -- iErr }: fsGetPos ;Primative 33				{ refNum -- ?pos iErr }: fsSetPos ;Primative 34				{ pos mode refNum -- iErr }{					}{ MACHINE REGISTERS	}{					}: rIP 0 ;: rMaxMem 4 ;: rRSP 8 ;: rS0 12 ;: rSP 16 ;: rNameBase 20 ;: rCurrent 24 ;: rContext 28 ;: rError 32 ;: rExitToShell 36 ;: rState 40 ;: rBootStack 44 ;: rTrace 48 ;: rSpan 52 ;: rList 56 ;: rHere 60 ;	{ pseudo constants }	: TRUE -1 ;: FALSE 0 ;: Space 32 ;: Cr 10 Emit ;: fsAtMark 0 ;: fsFromStart 1 ;: fsFromLEOF 2 ;: fsFromMark 3 ;{		}{ WORDS	}{		}: IP rIP @ ;: MaxMem rMaxMem @ ;: RSP rRSP @ ThreadSize + ;: S0 rS0 @ ;: SP rSP @ ;: NameBase rNameBase @ ;: Current rCurrent @ ;: Context rContext @ ;: State rState @ ;: BootStack rBootStack @ ;: Trace 1 rTrace ! ;: NoTrace 0 rTrace ! ;: ListOn TRUE rList ! ;: ListOff FALSE rList ! ;: Span rSpan @ ;: Here rHere @ ;	{ low level words }	: (VARIABLE)						{ used by bootStart for user and return stack threads }	R> ;: Dup SP @ ;						{ X -- X X }: Over 							{ A B -- A B A }	SP ThreadSize + @ ;: Drop 							{ X -- }	rSP @ ThreadSize + rSP ! ;: Branch	R> @ >R ;: Swap							{ A B -- B A }	Over >R >R Drop R> R> ;: +!								{ val addr -- }	Dup >R							{ val addr }	@ +								{ (val + addrVal) }	R> ! ;							{ }: -!								{ val addr }	Dup >R							{ val addr }	@ Swap -							{ addrVal - val }	R> ! ;							{ }: Pick							{ X...A # -- X..A X }	>R								{ X..A }	SP R>							{ X...A SP # }	ThreadSize * + @ ;					{ X..A X }: Rot								{ A B C -- B C A }	2 Pick 							{ A B C A }		{ }	>R >R >R							{ A }				{ A C B }	Drop								{ }				{ A C B }	R> R> R> ;							{ B C A }: Execute rIP ! ;					{ addr --> IP }: Error rError @ Execute ;			{ execute thread stored at rError }: ExitToShell rExitToShell @ Execute ;	{ execute thread at rExitToShell }	{ dictionary management }	: CAllot rHere +! ;			{ size -- }: Allot					{ size -- }	ThreadSize 1 - +	ThreadSize / ThreadSize *	CAllot	;	{ definition of a word rec }	: wordRec_size 0 ;: wordRec_refCount 1 ; : wordRec_nextRec 2 ;: wordRec_unused1 3 ;: wordRec_flags 4 ;: wordRec_nameRec 5 ;: wordRec_FieldCount 6 ;: thread>wordRec_size 						{ thread -- sizeAddr }	wordRec_size wordRec_FieldCount - 	ThreadSize * + ; : thread>wordRec_refCount					{ thread -- refCountAddr }	wordRec_refCount wordRec_FieldCount - 	ThreadSize * + ; : thread>wordRec_nextRec					{ thread -- nextRecAddr }	wordRec_nextRec wordRec_FieldCount - 	ThreadSize * + ; : thread>wordRec_unused1					{ thread -- unused1Addr }	wordRec_unused1 wordRec_FieldCount - 	ThreadSize * + ; : thread>wordRec_flags						{ thread -- flagsAddr }	wordRec_flags wordRec_FieldCount - 	ThreadSize * + ; : thread>wordRec_nameRec					{ thread -- nameRecAddr }	wordRec_nameRec wordRec_FieldCount - 	ThreadSize * + ; : wordRec_size>thread						{ sizeAddr -- thread }	wordRec_FieldCount wordRec_size - 	ThreadSize * + ; : wordRec_refCount>thread					{ refCountAddr -- thread }	wordRec_FieldCount wordRec_refCount - 	ThreadSize * + ; : wordRec_nextRec>thread					{ nextRecAddr -- thread }	wordRec_FieldCount wordRec_nextRec - 	ThreadSize * + ; : wordRec_unused1>thread					{ unused1Addr -- thread }	wordRec_FieldCount wordRec_unused1 - 	ThreadSize * + ; : wordRec_flags>thread						{ flagsAddr -- thread }	wordRec_FieldCount wordRec_flags - 	ThreadSize * + ; : wordRec_nameRec>thread					{ nameRecAddr -- thread }	wordRec_FieldCount wordRec_nameRec - 	ThreadSize * + ; : SZ_wordRec wordRec_FieldCount ThreadSize * ;: fImmediateFlag 1 ;					{ the immediate flag is the low order bit of wordRec_flags }: fPrimativeFlag 2 ;					{ the immediate flag is the low order bit of wordRec_flags }: fCompileTimeFlag 4 ;				{ the immediate flag is the low order bit of wordRec_flags }: fRunTimeFlag 8 ;					{ the immediate flag is the low order bit of wordRec_flags }: Immediate	Current wordRec_size>thread thread>wordRec_flags	Dup @ fImmediateFlag | Swap ! ;	: CompileTime	Current wordRec_size>thread thread>wordRec_flags	Dup @ fCompileTimeFlag | Swap ! ;	: RunTime	Current wordRec_size>thread thread>wordRec_flags	Dup @ fRunTimeFlag | Swap ! ;	: [ FALSE rState ! ; Immediate: ] TRUE rState ! ; Immediate	{ Misc compiling words }	: <Mark							{ -- destAddr }	Here	; CompileTime						{ put branch addr on stack }: <Resolve							{ destAddr -- }	Here ThreadSize Allot ! ; CompileTime: >Mark							{ -- branchLoc }	Here ThreadSize Allot ; CompileTime			{ allocate space for branch dest }: >Resolve							{ branchLoc -- }	Here Swap ! ; CompileTime: CompileTOS 						{ value to compile }	Here ThreadSize Allot ! ; CompileTime: Compile 							{ compile the tread following 'Compile' in caller }									{ WARNING! won't compile Immediate words }	R> Dup ThreadSize + >R @				{ skip and fetch next thread }	CompileTOS ; CompileTime			{ compile it into new word }: CompileLiteralTOS					{ compile TOS as a literal value that is pushed at run time }	Compile (LITERAL)	CompileTOS ; CompileTime: TOS ; Immediate					{ does nothing }	{ control structure words }	{ IF boolean THEN .. ENDIF }{ IF boolean THEN .. ELSE .. ENDIF }{ REPEAT num TIMES .. ENDREPEAT }			{ 0 <= i < num }{ WHILE boolean DO .. ENDWHILE }: IF ; Immediate	 CompileTime			{ just for show }: THEN							{ compile a conditional forward branch }	Compile ?Branch 	>Mark ; Immediate CompileTime: ELSE							{ ELSE }	>R								{ save THEN mark }	Compile Branch	>Mark							{ mark this for forward branch to ENDIF }	R> >Resolve ; Immediate CompileTime	{ resolve THEN mark }: ENDIF							{ compile destination of forward branch }	>Resolve ; Immediate CompileTime	: i 								{ -- index }	RSP ThreadSize + @ 1 - ;: j 								{ -- index }	RSP ThreadSize 3 * + @ 1 - ;: i! 								{ -- index }	RSP ThreadSize + ! ;: j! 								{ -- index }	RSP ThreadSize 3 * + ! ;: Leave							{ }	RSP ThreadSize + 				{ &i }	Dup 							{ &i &i }	ThreadSize + 					{ &i &limit }	@ Swap ! ;: (IndexLoop)						{ -- }			{ limit ndx ret }	R> R> R>						{ ret ndx limit }		{ }	IF Over Over > THEN				{ ret ndx limit }		{ }		Drop Drop					{ ret }			{ }		@ >R						{ }				{ ret@ }	ELSE		>R						{ ret ndx }			{ limit }		1 +						{ ret ndx+ }		{ limit }		>R						{ ret }			{ limit ndx+ }		ThreadSize + >R			{ }				{ linit ndx ret+ }	ENDIF	;: REPEAT ; Immediate CompileTime: (Times)						{ limit -- }	1 -							{ index goes from 0 to limit-1 }	R> 							{ limit ret }		{ }	Swap						{ ret limit }		{ }	>R 							{ ret }			{ limit }	0 							{ ret 0 }			{ limit }	>R 							{ ret }			{ limit 0 }	>R							{ }				{ limit 0 ret }	;: TIMES	Compile (Times)	<Mark	Compile (IndexLoop)	>Mark	Swap	; Immediate CompileTime: ENDREPEAT	Compile Branch	<Resolve	>Resolve	; Immediate CompileTime: WHILE	<Mark ; Immediate: DO	Compile ?Branch	>Mark 	Swap	; Immediate: ENDWHILE	Compile Branch	<Resolve	>Resolve ; Immediate: (String)					{ -- addr }	R>						{ ret=strAddr }	Dup						{ ret strAddr }	WHILE Dup C@ DO			{ ret strAddr }		1 +					{ ret strAddr+ }	ENDWHILE					{ ret strAddr+ }	1 + { skip null }				{ ret strAddr+ }	ThreadSize 1 - +			{ ret setAddr+ThreadSize-1 }	ThreadSize / ThreadSize *	{ ret setAddr+ThreadSize-1*ThreadSize/ThreadSize }	>R ;						{ ret }		{ logical operators and stuff }		: Not							{ TRUE -- FALSE }	{ FALSE -- TRUE }	FALSE = ;: Or								{ b1 b2 -- b3 }	IF TOS THEN						{ b1 b2 }		Drop							{ }		TRUE							{ TRUE }	ELSE 		FALSE = Not	ENDIF ; : And	Not	Swap 	Not	Or Not	;: Xor								{ b1 b2 -- (b1&!b2)||(!b1&&b2) }	Not								{ b1 !b2 }	Swap 							{ !b2 b1 }	Not								{ !b2 !b1 }	= Not ;: Neg 0 Swap - ;: <= 	IF Over Over < THEN		Drop Drop TRUE	ELSE		=	ENDIF ;: >= 	IF Over Over > THEN		Drop Drop TRUE	ELSE		=	ENDIF ;: Abs	IF Dup 0 < THEN		Neg	ENDIF ;	: ?Dup 	IF Dup THEN		Dup	ENDIF ;: Count					{ textAddr -- textAddr count }	0 						{ textAddr 0 }	Over						{ textAddr 0 textAddr }	WHILE Dup C@ DO		1 + 					{ textAddr 0 textAddr+ }		>R					{ textAddr 0 }				{ textAddr+ }		1 + 					{ textAddr 0+ }		R>					{ textAddr 0+ textAddr+ }	ENDWHILE					{ textAddr count textAddr+ }	Drop ;					{ textAddr count }: Type					{ textAddr count -- }	REPEAT TOS TIMES			{ textAddr }		Dup C@ 		IF Dup 13 = THEN			Drop 10		ENDIF		Emit					{ textAddr }		1 +					{ textAddr+ }	ENDREPEAT	 			{ textAddr+ }	Drop ;					{ }	: Print Count Type ;: Base (VARIABLE) ; 10 Base !: .	IF ?Dup THEN		0 Swap		IF Dup 0 < THEN			45 Emit			Neg		ENDIF		WHILE ?Dup DO			Dup Base @ %			IF Dup 9 > THEN				55 + Swap			ELSE				48 + Swap			ENDIF			Base @ /		ENDWHILE		WHILE ?Dup DO			Emit		ENDWHILE	ELSE		48 Emit	ENDIF	Space Emit ;		{ Exception stuff }	: eNoErr 0 ;				{ error code }: eNoError 0 ;				{ error code }: eNoHandler 100000 ;: eRecursiveExceptionCall 100001 ;: eFibInUse 100002 ;			{ error code }: eFibIOError 100003 ;		{ error code }: eIllegalCharacterConstant 100004 ;: eBadNumber 100005 ;: eExitSystem 100006 ;: gLastError (VARIABLE) ; 	eNoErr gLastError !: ^ExcNextFrame 0 ;: ^ExcCatch ThreadSize + ;: ^ExcSP ThreadSize 2 * + ;: ^ExcRSP ThreadSize 3 * + ;: SZ_ExcFrame ThreadSize 4 * ;: ExcTop (VARIABLE) ;			0 ExcTop !: LPush					{ node list }	Dup						{ node list list }	@						{ node list first }	2 Pick					{ node list first node }	!						{ node list }	!						{ }	;: LPop					{ list }	Dup						{ list list }	>R						{ list }	@						{ first }	Dup						{ first first }	@						{ first next }	Swap					{ next first }	0 Swap					{ next 0 first }	!						{ next }	R>						{ next list }	!						{ }	;	{ 	Here is what the exception macros build		: aWord		(Try)						 this routine save the SP, RSP, and links us into the ExcStack		link		#1		ExcSP		ExcRSP		the try part of the definition		(Success)		#2	#1	that catch part of the definition	#2	(EXIT) }: (Try)	R>	Dup SZ_ExcFrame + >R	IF Dup @ 0 = Not THEN		eRecursiveExceptionCall Error	ENDIF	ExcTop LPush	SP ExcTop @ ^ExcSP !	RSP ThreadSize +	ExcTop @ ^ExcRSP !	;: (Success)	R> @ >R	ExcTop LPop	;: Failure						{ iErr -- }	gLastError !	WHILE ExcTop @ DO		ExcTop @ ^ExcRSP @ rRSP !		ExcTop @ ^ExcSP @ rSP ! 		ExcTop @ ^ExcCatch @		ExcTop LPop		Execute	ENDWHILE	gLastError @ Error ;: ?Failure						{ iErr -- }	IF ?Dup THEN		Failure	ENDIF ;: NoPropagate	R> R> Drop >R ;: TRY	Compile (Try)	0 CompileTOS				{ link for LPush }	>Mark					{ for CATCH address }	SZ_ExcFrame ThreadSize 2 * - Allot	; Immediate CompileTime: CATCH	>R						{ save >Mark address }	Compile (Success)	>Mark					{ to branch over exception part }	R> >Resolve	; Immediate CompileTime: ENDTRY	>Resolve	; Immediate CompileTime	{ Back to more normal things }	: Convert					{ addr -- n }	0 >R						{ addr }	WHILE Dup C@ Dup DO		{ addr c }		IF Dup 58 < THEN		{ is decimal digit < '9'+1 }			48 -				{ addr dv }		ELSE					{ is a letter }			55 -				{ addr dv }		ENDIF		IF Dup Base @ >= THEN			eBadNumber Failure		ENDIF		R>					{ addr dv v }		Base @ 				{ addr dv v base }		* 					{ addr dv v*base }		+					{ addr v }		>R					{ addr }		1 +					{ addr+ }	ENDWHILE					{ addr+ }	Drop R> ;					{ v }: Fill						{ addr n byte -- }	{ fill n bytes with byte starting at addr }	Rot	Rot	REPEAT TOS TIMES			{ byte addr }		Over Over C!			{ byte addr }		1 +					{ byte addr+ }	ENDREPEAT				{ byte addr }	Drop Drop ;				{ }	{ Block handling and I/O stuff }: ^QueryIn ; Immediate: ^In ThreadSize + ;: ^#In ThreadSize 2 * + ;: ^>In ThreadSize 3 * + ;: ^|In ThreadSize 4 * + ;: QueryBuf (VARIABLE) ;: Query	QueryBuf @ ^QueryIn @	Execute ;: In	QueryBuf @ ^In @ Execute ;: #In	QueryBuf @ ^#In @ Execute ;: >In	QueryBuf @ ^>In @ Execute ;: |In	QueryBuf @ ^|In @ Execute ;: ?In	WHILE >In @ #In @ >= DO		Query	ENDWHILE	>In @ In + C@	|In	;: @In	?In	1 >In +!	;: SZ_Tib 80 ;: TibBuffer (VARIABLE) ;	SZ_Tib Allot: #Tib (VARIABLE) ;		0 #Tib !: >Tib (VARIABLE) ;		0 >Tib !: FilterTib	IF Dup 32 < THEN		Drop 32	ENDIF	;: QueryTib	" ?" Print	TibBuffer SZ_Tib 1 - Expect	32 Span TibBuffer + !	Span 1 + #Tib !	0 >Tib !	;: Tib	(VARIABLE)	QueryTib	TibBuffer	#Tib	>Tib	FilterTib	;Tib QueryBuf !: SZ_Fib 1024 ;: FibBuffer (VARIABLE) ;	SZ_Fib Allot: #Fib (VARIABLE) ;		0 #Fib !: >Fib (VARIABLE) ;		0 >Fib !: FibRefNum (VARIABLE) ;	0 FibRefNum !: CloseFib	IF FibRefNum @ THEN		FibRefNum @ fsClose		0 FibRefNum !		Tib QueryBuf !		?Failure	ENDIF	;: FilterFib	IF Dup 32 < THEN		Drop 32	ENDIF	;: QueryFib					{ Fib -- Fib/addr }	SZ_Fib FibBuffer FibRefNum @	fsRead	Drop	IF Span 0 = THEN		CloseFib		Query	ELSE		Span #Fib !		0 >Fib !	ENDIF	;: Fib	(VARIABLE)	QueryFib	FibBuffer	#Fib	>Fib	FilterFib	;: OpenFib	CloseFib	fsOpen	?Failure	FibRefNum !	Fib QueryBuf !	;: SZ_WordBuf 256 ;: WordBuf (VARIABLE) ; SZ_WordBuf ThreadSize - Allot: Word 							{ char -- addr }	WHILE Dup ?In = DO					{ char }		@In Drop						{ char }	ENDWHILE							{ char }	WordBuf								{ char addr }	WHILE Over ?In = Not DO				{ char addr }		@In Over						{ char addr c addr }		C!							{ char addr }		1 +							{ char addr+ }	ENDWHILE							{ char addr+ }	0 Swap !							{ char }	Drop								{ }	WordBuf ;							{ addr }: strcmp 							{ str1 str2 -- val }	WHILE		Over Over C@ Swap C@		Over Over		And >R = R> And DO		1 + >R 1 + R>	ENDWHILE	C@ >R C@ R> -	;: strcpy							{ str1 str2 --  }	WHILE Over C@ ?Dup DO				{ str1 str2 c }		Over C!						{ str1 str2 }		1 + >R						{ str1 }		1 + R>						{ str1+ str2+ }	ENDWHILE							{ str1+ str2+ }	0 Swap C!							{ str1+ }	Drop								{ }	;: findToken 						{ str1 -- addr }	NameBase							{ str1 nameRec }	WHILE Dup (LITERAL) pUndefinedWord = Not DO		wordRec_size>thread 			{ str1 thread }		Dup							{ str1 thread thread }		ThreadSize +					{ str1 thread name }		IF 2 Pick strcmp Not THEN			{ str1 thread }			Swap 					{ thread str1 }			Drop 					{ thread }			thread>wordRec_size		{ nameRec }			(EXIT)		ENDIF		thread>wordRec_nextRec @		{ str1 nameRec }	ENDWHILE							{ str1 nameRec }	Drop Drop 0						{ 0 }	;	 { *** HeyJF - you tested up to here *** }: beginWord						{ nextWord nameRec -- }	R> Here >R >R 						{ }	Here SZ_wordRec 0 Fill				{ }	Here wordRec_size>thread	Dup >R	thread>wordRec_nameRec !	R>	thread>wordRec_nextRec !	SZ_wordRec Allot					{ }	;: endWord							{ -- }	R> R> 							{ ret word }	Dup								{ ret word word }	Here 							{ ret word word here }	Swap -							{ ret word size }	Swap !							{ ret }	>R								{ }	;: CompileString						{ str -- }	Here strcpy						{ }	Here Count  1 +						{ size }	Allot								{ }	;: getToken							{ str1 -- addr }	IF Dup findToken ?Dup Not THEN			{ str1 }		Here >R						{ str1 }	{ token }		NameBase Here beginWord			{ str1 }		(LITERAL) pUndefinedWord					CompileTOS					{ str1 } 	{ token }		CompileString					{ }		endWord						{ }		R>							{ token }		Dup rNameBase !				{ token }	ELSE								{ str1 token }		Swap Drop					{ token }	ENDIF							{ token }	;: :	Current							{ nextRec }	Space Word						{ nextRec addr }	getToken							{ nextRec nameRec }	beginWord							{  }	TRUE rState !	; RunTime: ;	Compile (EXIT)	endWord	FALSE rState !	Current rContext !	; Immediate CompileTime: Find										{ str -- thread }	findToken										{ token }	IF Dup THEN									{ token }		Current									{ token word }		WHILE Dup (LITERAL) pUndefinedWord = Not DO		{ token word }			wordRec_size>thread					{ token thread }			IF Over Over thread>wordRec_nameRec @ = THEN				Swap Drop				Dup				thread>wordRec_flags @				(EXIT)			ENDIF			thread>wordRec_nextRec			@		ENDWHILE		Drop Drop -1	ENDIF	;: Interpret		{ interpret the input stream }		{ -- Ànumber? }	WHILE TRUE DO		Cr " >" Print				{ hey jf - you added this prompt }		Space Word								{ text }		Find										{ addr flag }		IF Dup 0 < THEN								{ addr flag }			{  word was not found }					{ text -1 }			Drop									{ text }			Convert								{ val }			IF State 0 = Not THEN				CompileLiteralTOS			ENDIF		ELSE			IF Dup fImmediateFlag & State 0 = Or THEN				Execute			ELSE				CompileTOS			ENDIF		ENDIF	ENDWHILE	;: GoForth	WHILE TRUE DO		TRY			Interpret		CATCH			IF gLastError @ eExitSystem = THEN				NoPropagate				(EXIT)			ELSE				Cr				" ***Error #" Print				gLastError @ .				Cr				NoPropagate			ENDIF		ENDTRY	ENDWHILE	;: System.Startup	TRY		" Forth.Blocks" OpenFib	CATCH		NoPropagate	ENDTRY	GoForth	CloseFib	;{ Trace }