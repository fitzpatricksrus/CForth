: !@								{ val Addr }	Over							{ val addr val }	Swap						{ val val addr }	! ;							{ val }: @++							{ addr -- val addr+ }	Dup >R	@	R> ThreadSize + ;: !++								{ val addr -- addr+ }	Dup >R	!	R> ThreadSize + ;{ FROM start TO stop ITERATE .. ENDFROM }	{ start <= i <= stop }{ : macroName ... MACRO ... ENDMACRO ... ; CompileTime Immediate	all the code betwen MACRO and ENDMACRO will be copied thread by thread onto the end	of the code stack when 'macroName' is compiled or executed }{ RECURSE	compile a thread to the 'Current' dictionary item's first thread }: FROM ; Immediate CompileTime: TO ; Immediate CompileTime: (Iterate)						{ ndx limit -- }			{ ret -- limit ndx ret }	R> 							{ ndx limit ret }		{ }	Rot							{ limit ret ndx }	Rot							{ ret ndx limit }	>R 							{ ret }			{ limit }	>R 							{ ret }			{ limit ndx }	>R							{ }				{ limit ndx ret }	;: ITERATE	Compile (Iterate)	<Mark	Compile (IndexLoop)	>Mark	Swap	; Immediate CompileTime: ENDFROM	Compile Branch	<Resolve	>Resolve	; Immediate CompileTime: (+EndFrom)	RSP ThreadSize + +! ;: +ENDFROM	Compile (+EndFrom)	Compile Branch	<Resolve	>Resolve	; Immediate CompileTime: (MACRO)				{ followed by dest branch address }	R> Dup @ Dup 				{ next end=branch branch }	>R						{ next end }	Swap ThreadSize + Swap		{ start end }				{ skip the branch data thread }	Over						{ start end start }	- ThreadSize /				{ start #ofThreads }	REPEAT TOS TIMES			{ start }		Dup 					{ start start }		@ CompileTOS			{ start }		ThreadSize +			{ start+ }	ENDREPEAT				{ start+ }	Drop ;					{ }: MACRO 	Compile (MACRO)	>Mark ; Immediate CompileTime: ENDMACRO	>Resolve ; Immediate CompileTime: RECURSE	Current wordRec_size>thread CompileTOS ; Immediate CompileTime: COMPILES>	Immediate				{ make compiling word immediate }	Compile Compile	>Mark 				{ this is what the compiled items is supposed to do }	; Immediate CompileTime: DOES>	Compile (EXIT)	>Resolve	Compile R>	; Immediate CompileTime: CMove	{ addr1 addr2 n }	{ move n bytes upward from addr1 to addr2 }	REPEAT TOS TIMES			{ addr1 addr2 }		Over C@				{ addr1 addr2 c }		Over C!				{ addr1 addr2 }		1 +					{ addr1 addr2+ }		>R					{ addr1 }		1 +					{ addr1+ }		R>					{ addr1+ addr2+ }	ENDREPEAT				{ addr1+ addr2+ }	Drop Drop ;				{ }: OffsetVariable			{ Offset Size -- }	COMPILES>		Swap		ThreadSize +		CompileTOS		ThreadSize - Allot	DOES>		Dup @ +	; Immediate CompileTime: ARRAY					{  Size -- }	COMPILES>		1 - ThreadSize * Allot	DOES>					{ ndx addr }		Swap				{ addr ndx }		ThreadSize * +			{ addr }	; Immediate CompileTime: CARRAY					{  Size -- }	COMPILES>		Allot	DOES>					{ ndx addr }		Swap				{ addr ndx }		+					{ addr }	; Immediate CompileTime: BoundedARRAY			{ startNdx stopNdx -- }	COMPILES>		Over		CompileTOS		Swap -		ThreadSize *		Allot	DOES>					{ ndx addr }		@++					{ ndx val addr }		>R					{ ndx val }		-					{ relNdx }		ThreadSize *			{ relOffset }		R> +					{ addr }	; Immediate CompileTime: BoundedCARRAY			{ startNdx stopNdx -- }	COMPILES>		Over		CompileTOS		Swap -		Allot	DOES>					{ ndx addr }		@++					{ ndx val addr }		>R					{ ndx val }		-					{ relNdx }		R> +					{ addr }	; Immediate CompileTime: (Package)					{ ndx -- ??? }	IF ?Dup THEN		R>						{ ndx r }		@						{ ndx tableEnd }		Swap					{ tableEnd ndx }		ThreadSize *				{ tableEnd offset }		Over						{ tableEnd offet tableEnd }		Swap					{ tableEnd tableEnd offset }		-						{ tableEnd procAddr }		@						{ tableEnd proc }		>R						{ tableEnd }	ELSE		R> @ 	ENDIF	;: PACKAGE	Compile (Package)	>Mark	-1	; Immediate CompileTime: SLOT	IF Dup -1 = Not THEN		Compile (EXIT)	ENDIF	<Mark	; Immediate CompileTime: ENDPACKAGE	Compile (EXIT)	WHILE Dup -1 = Not DO		<Resolve	ENDWHILE	Drop	>Resolve	; Immediate CompileTime: #Pad 80 ;: Pad (VARIABLE) ; #Pad ThreadSize - Allot: Hold	1 Pad -!					{ char }	Pad @ C!					{ char }	;: <#	80 Pad + Pad !	0 Hold 	;: #	Dup Base @ %				{ num val }	IF Abs Dup 9 >  THEN			{ num val }		55 +					{ num dig }	ELSE						{ num val }		48 +					{ num dig }	ENDIF					{ num dig }	Hold						{ num }	Base @ /					{ num/ }	;: #S	WHILE Dup DO				{ num }		#					{ num/ }	ENDWHILE					{ num/ }	;						{ }: Sign	IF Swap 0 < THEN		45 Hold	ELSE		Space Hold	ENDIF ;: #>	Drop	Pad @	Count	;: .S	S0 . SP .	123 Emit Space Emit	REPEAT SP S0 Swap - ThreadSize / TIMES		S0 i 1 + ThreadSize * -		@ Dup <# Space Hold Space Hold # # # # # # # # Sign #> Type	ENDREPEAT	125 Emit Cr ;: .C						{ addr n  -- }	{ print n bytes starting at addr }	REPEAT TOS TIMES		IF i 32 % Not THEN			Cr Dup i + .			Dup <# Space Hold Space Hold # # # # Space Hold # # # # Sign #> Type		ENDIF		Dup i + C@ 		<# Space Hold # # Sign #> Type							{ byte addr }	ENDREPEAT				{ byte addr }	Drop Cr ;					{ }: "	34 { " } Word	IF State THEN		Compile (String)		CompileString	ELSE		Print	ENDIF	; Immediate: '	39 { ' } Word	IF Count 1 = Not THEN		eIllegalCharacterConstant Failure	ENDIF	Convert	IF State THEN		CompileLiteralTOS	ENDIF	; Immediate: ."	34 { " } Word	IF State THEN		Compile (String)		CompileString		Compile Print	ELSE		Print	ENDIF	; Immediate