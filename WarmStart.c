#include "WarmStart.h"#include <stdio.h>#include <String.h>#include <Profile.h>#define PToCString( p, c) 			\	BlockMove( p+1, c, p[0]);		\	c[p[0]] = 0#define CToPString( c, p)			\	{						\	short x = strlen( c);			\	BlockMove( c, p+1, x);		\	p[0] = x;					\	}char *(primName[]) = {	"C@",	"@",	"!",	"C!",	"?Branch",	"|",	"&",	"^",	"~",	"+",	"-",	"/",	"*",	"%",	"=",	">",	"<",	"Expect",	"Emit",	"pUndefinedWord",	"pExitToShell",	"(LITERAL)",	"(EXIT)",	">R",	"R>",	"ThreadSize",	"fopen",	"fclose",	"fcreate",	"fdelete",	"fread",	"fwrite"	};// FORTH system error codesenum { feNoErr, feUnknownPrimative };Boolean threadInWord( Ptr mem, token cWord, token thread);static Boolean threadInWord( Ptr mem, token cWord, token thread)	{		token lower = cWord;		token upper = cWord + tokenVal( cWord + wordRec_size);		return( thread >= lower && thread <= upper);	}	token findWordFromThread( Ptr mem, token thread);static token findWordFromThread( Ptr mem, token thread)	{		token cWord;		if (thread < 0)			cWord = thread;		else {			cWord = tokenVal( fContext);			while (cWord != pUndefinedWord && !threadInWord( mem, cWord, thread)) 				cWord = tokenVal( cWord + wordRec_nextRec);			return( cWord);		}		return( cWord);	}	char *nameOfWord( Ptr mem, token word);static char *nameOfWord( Ptr mem, token word)	{		if (word < 0)			return( primName[ -word - 1]);		else			return( mem + nameRec_nameStr +				tokenVal( wordRec_nameRec + word));	}char *surroundingName( Ptr mem, token word)	{		return( nameOfWord( mem, findWordFromThread( mem, word)));	}#define PUSH( stackPtr, val) PushX( mem, stackPtr, val)#define POP( stackPtr) PopX( mem, stackPtr)void PushX( Ptr mem, token stackPtr, token val);static void PushX( Ptr mem, token stackPtr, token val)	{		tokenVal( stackPtr) -= sizeof( token);		tokenVal( tokenVal( stackPtr)) = val;	}token PopX( Ptr mem, token stackPtr);static token PopX( Ptr mem, token stackPtr)	{		token rVal;		ASSERT((stackPtr != fSP) || (tokenVal( fSP) < tokenVal( fS0)));		rVal = tokenVal( tokenVal( stackPtr));		tokenVal( stackPtr) += sizeof( token);		return( rVal);	}void traceIt( Ptr mem, token stackBase);static void traceIt( Ptr mem, token stackBase)	{		if (tokenVal( fTrace)) {			short i;			#if __option( profile)				_profile = FALSE;				DumpProfile();			#endif			for (i = (stackBase - tokenVal( fRSP)) / sizeof( token); i > 0; i--) printf( "  ");			printf( "\t\t\t{ %05ld } ", (long)tokenVal( fSP));			for (i = 2; i >= 0; i--) {				token limit, p;				limit = tokenVal( fS0);				p = tokenVal( fSP) + i*sizeof(token);				printf( "%05ld ", (p < limit) ? (long)tokenVal( p) : 0L);			}			printf( "-- { %05ld } ", (long)tokenVal( fRSP));			for (i = 2; i >= 0; i--) {				token limit, p;				limit = stackBase;				p = tokenVal( fRSP) + i*sizeof(token);				printf( "%05ld ", (p < limit) ? (long)tokenVal( p) : 0L);			}			printf( "\n");			printf( "\t%ld\t ", (long)tokenVal( fIP));			for (i = (stackBase - tokenVal( fRSP)) / sizeof( token); i > 0; i--) printf( "  ");			printf( "%s::",				nameOfWord( mem, findWordFromThread( mem, tokenVal( fIP))));			printf( "%s\n",				nameOfWord( mem, findWordFromThread( mem, tokenVal( tokenVal( fIP)))));		}	}void WarmStart( Ptr mem)	{		token thread;		token stackBase;				#if __option( profile)			_profile = TRUE;		#endif					stackBase = tokenVal( fRSP);		tokenVal( fRSP) -= sizeof( token);				// make main function of FORTH		tokenVal( tokenVal( fRSP)) = tokenVal( fExitToShell);//   return to 'fExitToShell' 		goto interp;		colon:			tokenVal( fRSP) -= sizeof( token);			// alloc space on return stack			tokenVal( tokenVal( fRSP)) = tokenVal( fIP);	// put IP on return stack			tokenVal( fIP) = thread;					// IP = thread		interp:			traceIt( mem, stackBase);			thread = tokenVal( tokenVal( fIP));			// thread = token at IP			tokenVal( fIP) += sizeof( token);			// move IP forward 1 thread			if (thread >= 0) goto colon;						primative:			switch (thread) {			case pCAt: goto CAt;			case pAt: goto AT;			case pStore: goto Store;			case pCStore: goto CStore;			case pCondBranch: goto CondBranch;			case pBitOr: goto BitOr;			case pBitAnd: goto BitAnd;			case pBitNot: goto BitNot;			case pBitXor: goto BitXor;			case pPlus: goto Plus;			case pMinus: goto Minus;			case pDivide: goto Divide;			case pMultiply: goto Multiply;			case pModulus: goto Modulus;			case pEqual: goto Equal;			case pGreater: goto Greater;			case pLess: goto Less;			case pExpect: goto Expect;			case pEmit: goto Emit;			case pUndefinedWord: goto UndefinedWord;			case pExitToShell: goto exitToShell;			case pLiteral: goto Literal;			case pExit: goto Exit;			case pToRS: goto toRS;			case pFromRS: goto fromRS;			case pThreadSize: goto threadSize;			case pfopen: goto openFile;			case pfclose: goto closeFile;			case pfcreate: goto createFile;			case pfdelete: goto deleteFile;			case pfread: goto readFile;			case pfwrite: goto writeFile;			case pfgetPos: goto getPos;			case pfsetPos: goto setPos;			default:				// push an error code on user stack and call 'error'				tokenVal( fSP) -= sizeof( token);				tokenVal( tokenVal( fSP)) = feUnknownPrimative;				tokenVal( tokenVal( fIP)) = tokenVal( fError);				goto exitPrimative;			}		exitPrimative:			if (tokenVal( fIP) < 0) goto primative;			goto interp;		//		// primative routines		//		CAt: {			PUSH( fSP, *(mem + POP( fSP)));			} goto exitPrimative;		AT:			PUSH( fSP, tokenVal( POP( fSP)));			goto exitPrimative;		Store: {			token dest = POP( fSP);			token val = POP( fSP);			tokenVal( dest) = val;			} goto exitPrimative;		CStore: {			token dest = POP( fSP);			token val = POP( fSP);			*(mem + dest) = val;			} goto exitPrimative;		CondBranch:			if (POP( fSP)) {				tokenVal( fIP) += sizeof( token);			} else {				tokenVal( fIP) = tokenVal( tokenVal( fIP));			} goto exitPrimative;		BitOr: {			token val1 = POP( fSP);			token val2 = POP( fSP);			PUSH( fSP, val1 | val2);			} goto exitPrimative;		BitAnd: {			// val2 val1 -- 			token val1 = POP( fSP);			token val2 = POP( fSP);			PUSH( fSP, val2 & val1);			} goto exitPrimative;		BitNot:			tokenVal( tokenVal( fSP)) = ~tokenVal( tokenVal( fSP));			goto exitPrimative;		BitXor: {			// val2 val1			token val1 = POP( fSP);			token val2 = POP( fSP);			PUSH( fSP, val2 ^ val1);			} goto exitPrimative;		Plus: {			// val2 val1			token val1 = POP( fSP);			token val2 = POP( fSP);			PUSH( fSP, val2 + val1);			} goto exitPrimative;		Minus: {			// val2 val1			token val1 = POP( fSP);			token val2 = POP( fSP);			PUSH( fSP, val2 - val1);			} goto exitPrimative;		Divide: {			// val2 val1			token val1 = POP( fSP);			token val2 = POP( fSP);			PUSH( fSP, val2 / val1);			} goto exitPrimative;		Multiply: {			// val2 val1			token val1 = POP( fSP);			token val2 = POP( fSP);			PUSH( fSP, val2 * val1);			} goto exitPrimative;		Modulus: {			// val2 val1			token val1 = POP( fSP);			token val2 = POP( fSP);			PUSH( fSP, val2 % val1);			} goto exitPrimative;		Equal: {			// val2 val1			token val1 = POP( fSP);			token val2 = POP( fSP);			PUSH( fSP, (val2 == val1) ? -1 : 0 );			} goto exitPrimative;		Greater:{			// val2 val1			token val1 = POP( fSP);			token val2 = POP( fSP);			PUSH( fSP, (val2 > val1) ? -1 : 0 );			} goto exitPrimative;		Less:{			// val2 val1			token val1 = POP( fSP);			token val2 = POP( fSP);			PUSH( fSP, (val2 < val1) ? -1 : 0 );			} goto exitPrimative;		Expect: {			token len;			token addr;			char buffer[256];			len = POP( fSP);			addr = POP( fSP);			#if __option( profile)				_profile = FALSE;			#endif						gets( buffer);			#if __option( profile)				_profile = TRUE;			#endif						strncpy( mem+addr, buffer, (size_t)len);			*(mem+addr+len) = '\0';			tokenVal( fSpan) = strlen( mem+addr);			} goto exitPrimative;		Emit: {			short c = POP( fSP);			c = c << 8;			printf( "%s", &c);			} goto exitPrimative;		Literal: {			PUSH( fSP, tokenVal( tokenVal( fIP)));			tokenVal( fIP) += sizeof( token);			} goto exitPrimative;		Exit:			 tokenVal( fIP) = POP(  fRSP);			 goto exitPrimative;		toRS:			PUSH( fRSP, POP( fSP));			goto exitPrimative;		fromRS:			PUSH( fSP, POP( fRSP));			goto exitPrimative;		threadSize:			PUSH( fSP, sizeof( token));			goto exitPrimative;		openFile: {						// namePtr -- iErr			short vRefNum;			short fRefNum;			OSErr iErr;			Str255 fileName;			strncpy( (char*)fileName, mem+POP( fSP), 256);			fileName[255] = '\0';			CToPString( (char*)fileName, fileName);			iErr = GetVRefNum( CurResFile(), &vRefNum);			if (iErr == noErr) {				Str255 temp;				BlockMove(fileName, temp, sizeof(temp));;				iErr = FSOpen( temp, vRefNum, &fRefNum);			}			if (iErr == noErr) PUSH( fSP, fRefNum);			PUSH( fSP, iErr);			} goto exitPrimative;		closeFile: {					// refNum -- iErr			OSErr iErr;			iErr = FSClose( POP( fSP));			PUSH( fSP, iErr);			} goto exitPrimative;		createFile: {					// namePtr -- iErr			short vRefNum;			short fRefNum;			OSErr iErr;			Str255 fileName;			strncpy( (char*)fileName, mem+POP( fSP), 256);			fileName[255] = '\0';			CToPString( (char*)fileName, fileName);			iErr = GetVRefNum( CurResFile(), &vRefNum);			if (iErr == noErr) {				iErr = Create( fileName, vRefNum, '4th ', 'TEXT');			}			PUSH( fSP, iErr);			} goto exitPrimative;		deleteFile: {					// namePtr -- iErr			short vRefNum;			short fRefNum;			OSErr iErr;			Str255 fileName;			strncpy( (char*)fileName, mem+POP( fSP), 256);			fileName[255] = '\0';			CToPString( (char*)fileName, fileName);			iErr = GetVRefNum( CurResFile(), &vRefNum);			if (iErr == noErr) {				iErr = FSDelete( fileName, vRefNum);			}			PUSH( fSP, iErr);			} goto exitPrimative;		readFile: {						// count addr refNum -- iErr			token fRefNum;				//	fSpan holds actual read count			token bufPtr;			long inOutCount;			OSErr iErr;			fRefNum = POP( fSP);			bufPtr = POP( fSP);			inOutCount = POP( fSP);			iErr = FSRead( fRefNum, &inOutCount, mem+bufPtr);			tokenVal( fSpan) = inOutCount;			PUSH( fSP, iErr);			} goto exitPrimative;		writeFile: {					// count addr refNum -- iErr			token fRefNum;				//	fSpan holds actual write count			token bufPtr;			long inOutCount;			OSErr iErr;			fRefNum = POP( fSP);			bufPtr = POP( fSP);			inOutCount = POP( fSP);			iErr = FSWrite( fRefNum, &inOutCount, mem+bufPtr);			tokenVal( fSpan) = inOutCount;			PUSH( fSP, iErr);			} goto exitPrimative;		getPos: {						// refNum -- pos iErr			short refNum;			long pos;			OSErr iErr;			refNum = POP( fSP);			iErr = GetFPos( refNum, &pos);			if (iErr == noErr) PUSH( fSP, pos);			PUSH( fSP, iErr);			} goto exitPrimative;		setPos: {						// pos mode refNum -- iErr			long pos;			short refNum;			short mode;			refNum = POP( fSP);			mode = POP( fSP);			pos = POP( fSP);			PUSH( fSP, SetFPos( refNum, mode, pos));			} goto exitPrimative;		UndefinedWord:			printf( "Undefined word encountered!!!!\n");			// fall through to exitToShell;		exitToShell:			0;		#if __option( profile)			_profile = FALSE;		#endif				}