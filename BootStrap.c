#include "BootStrap.h"#include "WarmStart.h"#include <Stdio.h>#include <ctype.h>#include <string.h>#define fImmediate 0x01#define fPrimative 0x02#define fCompileTime 0x04#define fRunTime 0x08#define cEOF 0xFF#if __option( int_4)	#define memSize 16000					// in tokens	#define minReturnStackSize 512			// in tokens	#define minUserStackSize 512				// in tokens#else	#define memSize 16000					// in tokens	#define minReturnStackSize 512			// in tokens	#define minUserStackSize 512				// in tokens#endif#define bootFileName "System.BootStrap"#define bootWordName "System.Startup"static FILE *inFile;static unsigned char ThisChar;// JUST RUN OF THE MILL CODEtoken allocLo( Ptr mem, long size);static token allocLo( Ptr mem, long size)	{		token rVal;		if (tokenVal( fList)) printf( "% 8ld ", (long)tokenVal( fHere));		rVal = tokenVal( fHere);		tokenVal( fHere) += size;		if (tokenVal( fHere) >= tokenVal( fBootStack)) Failure( eOutOfMemory, 0);		return( rVal);	}	token allocHi( Ptr mem, long size);static token allocHi( Ptr mem, long size)	{		token rVal;		tokenVal( fBootStack) -= size;		rVal = tokenVal( fBootStack);		if (tokenVal( fHere) >= tokenVal( fBootStack)) Failure( eOutOfMemory, 0);		return( rVal);	}	token allocNameRec( Ptr mem, char *nameStr);static token allocNameRec( Ptr mem, char *nameStr)	{		token rVal;		short len;				len = strlen( nameStr)+1;		len = len + (sizeof( token) - len % sizeof( token)) + SZ_nameRec;			// NOTE: names are allocated from the top of memory downward at bootStrap		rVal = allocHi( mem, len);		tokenVal( rVal + nameRec_size) = len;		tokenVal( rVal + nameRec_refCount) = 0;		tokenVal( rVal + nameRec_unused1) = pUndefinedWord;		tokenVal( rVal + nameRec_flags) = 0;		tokenVal( rVal + nameRec_nameRec) = rVal;				tokenVal( rVal + nameRec_nextRec) = tokenVal( fNameBase);		tokenVal( rVal + nameRec_thread) = pUndefinedWord;		strcpy( mem + rVal + nameRec_nameStr, nameStr);		tokenVal( fNameBase) = rVal;		return( rVal);	}token findNameRec( Ptr mem, char *nameStr);static token findNameRec( Ptr mem, char *nameStr)	{		token rVal;				rVal = tokenVal( fNameBase);		while (rVal != pUndefinedWord && strcmp( mem + rVal + nameRec_nameStr, nameStr)) {			rVal = tokenVal( rVal + nameRec_nextRec);		}		if (rVal == pUndefinedWord) {			rVal = allocNameRec( mem, nameStr);		}		return( rVal);	}token allocWordRec( Ptr mem, char *nameStr);static token allocWordRec( Ptr mem, char *nameStr)	{		token rVal;		token name;				name = findNameRec( mem, nameStr);		rVal = allocLo( mem, SZ_wordRec);		if (tokenVal( fList)) printf( ": %s\n", nameStr);		tokenVal(  rVal + wordRec_size) = SZ_wordRec;			// no references yet		tokenVal(  rVal + wordRec_refCount) = 0;			// init unused fields		tokenVal(  rVal + wordRec_unused1) = pUndefinedWord;		tokenVal(  rVal + wordRec_flags) = 0;			// set our name record and increase its reference count		tokenVal(  rVal + wordRec_nameRec) = name;		tokenVal(  name + nameRec_refCount)++;			// link the fCurrent definition dictionary to this word		tokenVal( rVal + wordRec_nextRec) = tokenVal( fCurrent);			// link us into the current dictionary		tokenVal( fCurrent) = rVal;			// NOTE: wordRec_threads is allocated and set by compileWordList			// NOTE: fContext is set to point at this definition AFTER it is completed so that we			//	may call previous definitions that have the same name.		return( rVal);	}token findWordRec( Ptr mem, char *nameStr);static token findWordRec( Ptr mem, char *nameStr)	{		token name, rVal;				name = findNameRec( mem, nameStr);		rVal = tokenVal( fContext);		while (rVal != pUndefinedWord && tokenVal( rVal + wordRec_nameRec) != name) {			rVal = tokenVal( rVal + wordRec_nextRec);		}		if (rVal == pUndefinedWord) rVal = name;		return( rVal);	}unsigned char thisChar( void);static unsigned char thisChar()	{		return( ThisChar);	}	void nextChar( void);static void nextChar()	{		short c;		if (ThisChar != cEOF) {			c = fgetc( inFile);			ThisChar = c;		}	}	void skipWhiteSpace( void);static void skipWhiteSpace()	{		unsigned char c;				c = thisChar();		while (isspace( c)) {			nextChar();			c = thisChar();		}	}void parseWord1( char *nameStr);static void parseWord1( char *nameStr)	{		short len = 0;				skipWhiteSpace();		while (len < maxStrSize-1 && (thisChar() != cEOF) && !isspace( thisChar())) {			nameStr[len++] = thisChar();			nextChar();		}		nameStr[len] = '\0';				}	void parseWord( char *nameStr);static void parseWord( char *nameStr)	{		parseWord1( nameStr);		while (!strcmp( "{", nameStr)) {			while ((thisChar() != cEOF) && (strcmp( "}", nameStr))) {				parseWord1( nameStr);			}			parseWord1( nameStr);		}	}void RunWord( Ptr mem, char *nameStr);static void RunWord( Ptr mem, char *nameStr)	{		token bootWord;		bootWord = findWordRec( mem, nameStr);		if (bootWord >= tokenVal( fBootStack)) {			if (tokenVal( fList)) printf( "?%s\n", nameStr);		} else if (tokenVal( fState) == 0 && tokenVal( bootWord + wordRec_flags) & fCompileTime) {				Failure( eCompileTimeWordsCantBeRun, 0);		} else {			if (tokenVal( fList)) printf( "    ---- \t%s\n", nameStr);			tokenVal( fIP) = bootWord + wordRec_threads;			WarmStart( mem);		}	}void compileWord( Ptr mem, char *nameStr);static void compileWord( Ptr mem, char *nameStr)	{		token nextToken;		token thread;				ASSERT( tokenVal( fState) != 0);		nextToken = findWordRec( mem, nameStr);		ASSERT( wordRec_nameRec == nameRec_nameRec);		// NOTE: nameRec's are allocated above the stack		if (nextToken >= tokenVal( fBootStack)) {			// it was undefined and the nameRec was returned			//	in this case, we set up a link chain from the name rec to all unresolve			//	references to that item.  Later, during the link phase, we traverse this list an			//	resolve these references			token thread;			thread = allocLo( mem, sizeof( token));			tokenVal( thread) = tokenVal( nextToken + nameRec_thread);			tokenVal( nextToken + nameRec_thread) = thread;			printf( "\t[[%s]]\n", nameStr);		} else {			if (tokenVal( nextToken + wordRec_flags) & fPrimative) {				tokenVal( allocLo( mem, sizeof( token))) = 					tokenVal( nextToken + wordRec_threads);				tokenVal( nextToken + wordRec_refCount)++;				if (tokenVal( fList)) printf( "\t%s\n", nameStr); 			} else if (tokenVal( nextToken + wordRec_flags) & fRunTime) {				Failure( eRunTimeWordsCantBeCompiled, 0);			} else if (tokenVal( nextToken + wordRec_flags) & fImmediate) {				RunWord( mem, nameStr);			} else {				// it was found, so compile its thread address into the code				tokenVal( allocLo( mem, sizeof( token))) = nextToken + wordRec_threads;				tokenVal( nextToken + wordRec_refCount)++;				if (tokenVal( fList)) printf( "\t%s\n", nameStr);			}		}	}	void prepMem( Ptr mem, long size);static void prepMem( Ptr mem, long size)	{		token stack;		tokenVal( fIP) = fError;	// Note:  ColdStart will change this initial value							//	to point to the wordRec for 'GoForth'		tokenVal( fMaxMem) = size;		tokenVal( fNameBase) = pUndefinedWord;		tokenVal( fCurrent) = pUndefinedWord;		tokenVal( fContext) = pUndefinedWord;		tokenVal( fError) = fExitToShell;		tokenVal( fExitToShell) = pExitToShell;		tokenVal( fState) = -1;		tokenVal( fBootStack) = size;		tokenVal( fTrace) = 0;		tokenVal( fSpan) = 0;		//set this to -1 if you want a listing		tokenVal( fList) = -1;		tokenVal( fHere) = fHere + sizeof( token);			// now allocate word for shell		stack = allocWordRec( mem, "fShell");		tokenVal( stack + wordRec_refCount) = 1;		compileWord( mem, "(VARIABLE)");		tokenVal( stack + wordRec_size) = size;		tokenVal( fExitToShell) = tokenVal( fHere);		tokenVal( allocLo( mem, sizeof( token))) = pExitToShell;		if (tokenVal( fList)) printf( "\tshell space\n");		tokenVal(  fContext) = stack;		tokenVal(  fCurrent) = stack;			// now allocate word for returnStack		stack = allocWordRec( mem, "fReturnStack");		tokenVal( stack + wordRec_refCount) = 1;		compileWord( mem, "(VARIABLE)");		allocLo( mem, minReturnStackSize*sizeof( token));		if (tokenVal( fList)) printf( "\tstack space\n");		tokenVal( stack + wordRec_size) = tokenVal( fHere) - stack;		tokenVal( fRSP) = tokenVal( fHere);		tokenVal(  fContext) = stack;		tokenVal(  fCurrent) = stack;			// now allocate word for userStack		stack = allocWordRec( mem, "fUserStack");		tokenVal( stack + wordRec_refCount) = 1;		compileWord( mem, "(VARIABLE)");		allocLo( mem, minUserStackSize*sizeof( token));		if (tokenVal( fList)) printf( "\tstack space\n");		tokenVal( stack + wordRec_size) = tokenVal( fHere) - stack;		tokenVal( fS0) = tokenVal( fHere);		tokenVal( fSP) = tokenVal( fHere);		tokenVal(  fContext) = stack;		tokenVal(  fCurrent) = stack;		// set interp state		tokenVal( fState) = 0;	}void linkWord( Ptr mem, token cWord);static void linkWord( Ptr mem, token cWord)	{		token cName;		cName = tokenVal( cWord + wordRec_nameRec);		if (tokenVal( cName + nameRec_thread) != pUndefinedWord) {			token cLink;			printf( "Linking references to %s\n", mem + cName + nameRec_nameStr);			while (( cLink = tokenVal( cName + nameRec_thread)) != pUndefinedWord) {				printf( "\t%s\n", surroundingName( mem, cLink));				tokenVal( cName + nameRec_thread) = tokenVal( cLink);				tokenVal( cLink) = cWord + wordRec_threads;				tokenVal( cWord + wordRec_refCount)++;			}		}	}void compileInputStream( Ptr mem);static void compileInputStream( Ptr mem)	{		char nameStr[maxStrSize];				parseWord( nameStr);		while (nameStr[0]) {			if (tokenVal( fState) == 0) {				// interpreting				if (!strcmp( ":", nameStr)) {					// create word header					parseWord( nameStr);					allocWordRec( mem, nameStr);					// switch to compile mode					tokenVal( fState) = 1;				} else if (!strcmp( "\"", nameStr)) {					// compile a string					token here;					here = tokenVal( fHere);					nextChar();					while ((thisChar() != cEOF) && (thisChar() != '"')) {						*(mem + here) = thisChar();						nextChar();						here++;					}					if (thisChar() == '"') nextChar();					*(mem+here++) = '\0';					tokenVal( fSP) -= sizeof( token);					tokenVal( tokenVal( fSP)) = tokenVal( fHere);					if (tokenVal( fList)) printf( "    ---- \t\"%s\"\n", mem + tokenVal( fHere));				} else if (isdigit( nameStr[0]) || (nameStr[0] == '-' && isdigit( nameStr[1]))) {					// push literal value on user stack					token literalValue;					#if __option( int_4)						sscanf( nameStr, "%ld", &literalValue);					#else						sscanf( nameStr, "%d", &literalValue);					#endif					tokenVal( fSP) -= sizeof( token);					tokenVal( tokenVal( fSP)) = literalValue;					if (tokenVal( fList)) printf( "    ---- \t%s\n", nameStr);				} else {					RunWord( mem, nameStr);				}			} else {				// compiling				if (!strcmp( ";", nameStr)) {					// compile an exit opcode					compileWord( mem, "(EXIT)");					// set word size					tokenVal( tokenVal( fCurrent) + wordRec_size) = tokenVal( fHere) - tokenVal( fCurrent);					// set fContext to this word					tokenVal( fContext) = tokenVal( fCurrent);					tokenVal( fState) = 0;					linkWord( mem, tokenVal( fCurrent));				} else if (!strcmp( ";Primative", nameStr)) {					// compile primative opcode					token primative;					parseWord( nameStr);					#if __option( int_4)						sscanf( nameStr, "%ld", &primative);					#else						sscanf( nameStr, "%d", &primative);					#endif					tokenVal( allocLo( mem, sizeof( token))) = -primative;					if (tokenVal( fList)) printf( "\t;Primative %s\n", nameStr);					// mark word at primative					tokenVal( tokenVal( fCurrent) + wordRec_flags) |= fPrimative;					// compile an exit opcode					compileWord( mem, "(EXIT)");					// set word size					tokenVal( tokenVal( fCurrent) + wordRec_size) = tokenVal( fHere) - tokenVal( fCurrent);					// set fContext to this word					tokenVal( fContext) = tokenVal( fCurrent);					tokenVal( fState) = 0;					linkWord( mem, tokenVal( fCurrent));				} else if (!strcmp( "\"", nameStr)) {					// compile a string					token here;					compileWord( mem, "(String)");					here = tokenVal( fHere);					nextChar();					while ((thisChar() != cEOF) && (thisChar() != '"')) {						*(mem + allocLo( mem, sizeof( char))) = thisChar();						*(mem + tokenVal( fHere)) = '\0';						if (tokenVal( fList)) printf( "\t\'%s\'\n", (char*)(mem + tokenVal( fHere)-1));						nextChar();					}					if (thisChar() == '"') nextChar();					*(mem + allocLo( mem, sizeof( char))) = '\0';					if (tokenVal( fList)) printf( "\t'\\0'\n");					allocLo( mem,						((tokenVal( fHere) + sizeof( token) - 1) / sizeof( token) * sizeof( token))						- tokenVal( fHere));					if (tokenVal( fList)) printf( "\tpadding\n");				} else if (isdigit( nameStr[0]) || (nameStr[0] == '-' && isdigit( nameStr[1]))) {					// compile a literal number					token literalValue;					compileWord( mem, "(LITERAL)");					#if __option( int_4)						sscanf( nameStr, "%ld", &literalValue);					#else						sscanf( nameStr, "%d", &literalValue);					#endif					tokenVal( allocLo( mem, sizeof( token))) = literalValue;					if (tokenVal( fList)) printf( "\t%s\n", nameStr);				} else {					// compile a thread					compileWord( mem, nameStr);				}			}			parseWord( nameStr);			}	}void SaveMem( Handle mem);static void SaveMem( Handle mem)	{		Handle oldMem;		oldMem = GetResource( '4th ', 128);		if (oldMem) {			UseResFile( HomeResFile( oldMem));			RmveResource( oldMem);		}		AddResource( (Handle)mem, '4th ', 128, "\p");		WriteResource( mem);		DetachResource( mem);	}void BootStrap()	{		Handle mem = NULL;				TRY {			mem = NewHandleClear( memSize * sizeof( token));			FailMemError();			MoveHHi( mem);			HLock( mem);			prepMem( *mem, GetHandleSize( mem));			inFile = fopen( bootFileName, "r");			FailNIL( inFile);			ThisChar = ' ';			skipWhiteSpace();			compileInputStream( *mem);			fclose( inFile);			inFile = stdin;			RunWord( *mem, bootWordName);			SaveMem( mem);			DisposeHandle( mem);		} CATCH {			if (inFile != stdin) fclose( inFile);			if (mem) DisposHandle( mem);		} ENDTRY;	}